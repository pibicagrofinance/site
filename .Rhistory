reticulate::repl_python()
from pyspark.sql import SparkSession
# Inicializar uma sessão Spark
spark = SparkSession.builder \
.appName("Financial Market Analysis") \
.getOrCreate()
# Testar a inicialização
quit
system("java -version")
system("java -version")
Sys.getenv("JAVA_HOME")
Sys.getenv("PATH")
Sys.setenv(PATH = paste0(Sys.getenv("JAVA_HOME"), "/bin;", Sys.getenv("PATH")))
system("java -version")
library(reticulate)
reticulate::repl_python()
from pyspark.sql import SparkSession
spark = SparkSession.builder \
.appName("Test PySpark") \
.getOrCreate()
print("Spark session created successfully!")
spark.stop()
# Importar bibliotecas necessárias
import dask.dataframe as dd
# Importar bibliotecas necessárias
import dask.dataframe as dd
import pandas as pd
import matplotlib.pyplot as plt
# Definir os tickers das ações e o período de tempo
tickers = ["AAPL", "MSFT", "GOOG", "AMZN"]
start_timestamp = "1262304000"  # Timestamp para 2010-01-01
end_timestamp = "1698710400"    # Timestamp para 2023-10-31
# Função para obter dados históricos de ações do Yahoo Finance usando Dask
def get_data(ticker):
# URL para download dos dados CSV do Yahoo Finance
url = f'https://query1.finance.yahoo.com/v7/finance/download/{ticker}?period1={start_timestamp}&period2={end_timestamp}&interval=1d&events=history&includeAdjustedClose=true'
# Ler o CSV em um DataFrame do Dask
df = dd.read_csv(url)
# Adicionar uma coluna para identificar o ticker
df['Ticker'] = ticker
return df
# Coletar dados para cada ticker e combinar em um único DataFrame Dask
data_frames = [get_data(ticker) for ticker in tickers]
combined_data = dd.concat(data_frames)
# Converter a coluna 'Date' para o tipo datetime
combined_data['Date'] = dd.to_datetime(combined_data['Date'])
# Remover valores nulos na coluna 'Close'
combined_data = combined_data.dropna(subset=['Close'])
# Análise de Dados
# Calcular a média do preço de fechamento para cada ação
average_close = combined_data.groupby("Ticker")["Close"].mean().compute()
print("Média do preço de fechamento por ação:")
print(average_close)
# Calcular a volatilidade (desvio padrão) do preço de fechamento para cada ação
volatility = combined_data.groupby("Ticker")["Close"].std().compute()
print("\nVolatilidade do preço de fechamento por ação:")
print(volatility)
# Visualização dos Dados
# Converter o DataFrame Dask para Pandas para visualização
pandas_df = combined_data.compute()
# Criar uma figura para o gráfico
plt.figure(figsize=(10, 6))
# Plotar o preço de fechamento para cada ação
for ticker in tickers:
# Filtrar os dados para o ticker atual
data = pandas_df[pandas_df['Ticker'] == ticker]
# Plotar a série temporal do preço de fechamento
plt.plot(data['Date'], data['Close'], label=ticker)
# Configurar o título e os rótulos do gráfico
plt.title('Preço de Fechamento das Ações ao Longo do Tempo')
plt.xlabel('Data')
plt.ylabel('Preço de Fechamento (USD)')
# Adicionar uma legenda
plt.legend()
# Ajustar o layout para evitar sobreposição
plt.tight_layout()
# Exibir o gráfico
plt.show()
# Importar bibliotecas necessárias
import dask.dataframe as dd
import pandas as pd
import matplotlib.pyplot as plt
# Certificar-se de que as dependências estão instaladas
# Se necessário, descomente as linhas abaixo e execute uma vez
# !pip install dask[dataframe]
# !pip install aiohttp
# !pip install requests
# Definir os tickers das ações e o período de tempo
tickers = ["AAPL", "MSFT", "GOOG", "AMZN"]
# Converter datas para timestamps Unix
start_date = "2010-01-01"
end_date = "2023-10-31"
start_timestamp = int(pd.Timestamp(start_date).timestamp())
end_timestamp = int(pd.Timestamp(end_date).timestamp())
# Função para obter dados históricos de ações do Yahoo Finance usando Dask
def get_data(ticker):
# URL para download dos dados CSV do Yahoo Finance
url = f'https://query1.finance.yahoo.com/v7/finance/download/{ticker}?period1={start_timestamp}&period2={end_timestamp}&interval=1d&events=history&includeAdjustedClose=true'
# Ler o CSV em um DataFrame do Dask
df = dd.read_csv(url, storage_options={'headers': {'User-Agent': 'Mozilla/5.0'}})
# Adicionar uma coluna para identificar o ticker
df['Ticker'] = ticker
return df
# Coletar dados para cada ticker e combinar em um único DataFrame Dask
data_frames = [get_data(ticker) for ticker in tickers]
combined_data = dd.concat(data_frames)
# Converter a coluna 'Date' para o tipo datetime
combined_data['Date'] = dd.to_datetime(combined_data['Date'], errors='coerce')
# Remover valores nulos na coluna 'Close' e 'Date'
combined_data = combined_data.dropna(subset=['Close', 'Date'])
# Análise de Dados
# Calcular a média do preço de fechamento para cada ação
average_close = combined_data.groupby("Ticker")["Close"].mean().compute()
print("Média do preço de fechamento por ação:")
print(average_close)
# Calcular a volatilidade (desvio padrão) do preço de fechamento para cada ação
volatility = combined_data.groupby("Ticker")["Close"].std().compute()
print("\nVolatilidade do preço de fechamento por ação:")
print(volatility)
# Visualização dos Dados
# Converter o DataFrame Dask para Pandas para visualização
pandas_df = combined_data.compute()
# Criar uma figura para o gráfico
plt.figure(figsize=(10, 6))
# Plotar o preço de fechamento para cada ação
for ticker in tickers:
# Filtrar os dados para o ticker atual
data = pandas_df[pandas_df['Ticker'] == ticker]
# Ordenar os dados por data
data = data.sort_values('Date')
# Plotar a série temporal do preço de fechamento
plt.plot(data['Date'], data['Close'], label=ticker)
# Configurar o título e os rótulos do gráfico
plt.title('Preço de Fechamento das Ações ao Longo do Tempo')
plt.xlabel('Data')
plt.ylabel('Preço de Fechamento (USD)')
# Adicionar uma legenda
plt.legend()
# Ajustar o layout para evitar sobreposição
plt.tight_layout()
# Exibir o gráfico
plt.show()
# Importar bibliotecas necessárias
import yfinance as yf
import pandas as pd
import matplotlib.pyplot as plt
# Definir os tickers das ações e o período de tempo
tickers = ["AAPL", "MSFT", "GOOG", "AMZN"]
start_date = "2010-01-01"
end_date = "2023-10-31"
# Função para obter dados históricos de ações usando yfinance
def get_data(ticker):
# Baixar os dados usando yfinance
df = yf.download(ticker, start=start_date, end=end_date)
# Adicionar uma coluna para identificar o ticker
df['Ticker'] = ticker
# Resetar o índice para transformar a coluna 'Date' em coluna regular
df = df.reset_index()
return df
# Coletar dados para cada ticker e combinar em um único DataFrame pandas
data_frames = [get_data(ticker) for ticker in tickers]
combined_data = pd.concat(data_frames, ignore_index=True)
# Remover valores nulos na coluna 'Close' e 'Date'
combined_data = combined_data.dropna(subset=['Close', 'Date'])
# Análise de Dados
# Calcular a média do preço de fechamento para cada ação
average_close = combined_data.groupby("Ticker")["Close"].mean().reset_index()
print("Média do preço de fechamento por ação:")
print(average_close)
# Calcular a volatilidade (desvio padrão) do preço de fechamento para cada ação
volatility = combined_data.groupby("Ticker")["Close"].std().reset_index()
print("\nVolatilidade do preço de fechamento por ação:")
print(volatility)
# Visualização dos Dados
# Criar uma figura para o gráfico
plt.figure(figsize=(10, 6))
# Plotar o preço de fechamento para cada ação
for ticker in tickers:
# Filtrar os dados para o ticker atual
data = combined_data[combined_data['Ticker'] == ticker]
# Ordenar os dados por data
data = data.sort_values('Date')
# Plotar a série temporal do preço de fechamento
plt.plot(data['Date'], data['Close'], label=ticker)
# Configurar o título e os rótulos do gráfico
plt.title('Preço de Fechamento das Ações ao Longo do Tempo')
plt.xlabel('Data')
plt.ylabel('Preço de Fechamento (USD)')
# Adicionar uma legenda
plt.legend()
# Ajustar o layout para evitar sobreposição
plt.tight_layout()
# Exibir o gráfico
plt.show()
# Importar bibliotecas necessárias
import yfinance as yf
import pandas as pd
import matplotlib.pyplot as plt
# Definir os tickers das ações e o período de tempo
tickers = ["AAPL", "MSFT", "GOOG", "AMZN"]
start_date = "2010-01-01"
end_date = "2023-10-31"
# Função para obter dados históricos de ações usando yfinance
def get_data(ticker):
# Baixar os dados usando yfinance
df = yf.download(ticker, start=start_date, end=end_date)
# Adicionar uma coluna para identificar o ticker
df['Ticker'] = ticker
# Resetar o índice para transformar a coluna 'Date' em coluna regular
df = df.reset_index()
return df
# Coletar dados para cada ticker e combinar em um único DataFrame pandas
data_frames = [get_data(ticker) for ticker in tickers]
combined_data = pd.concat(data_frames, ignore_index=True)
# Remover valores nulos na coluna 'Close' e 'Date'
combined_data = combined_data.dropna(subset=['Close', 'Date'])
# Análise de Dados
# Calcular a média do preço de fechamento para cada ação
average_close = combined_data.groupby("Ticker")["Close"].mean().reset_index()
print("Média do preço de fechamento por ação:")
print(average_close)
# Calcular a volatilidade (desvio padrão) do preço de fechamento para cada ação
volatility = combined_data.groupby("Ticker")["Close"].std().reset_index()
print("\nVolatilidade do preço de fechamento por ação:")
print(volatility)
# Visualização dos Dados
# Criar uma figura para o gráfico
plt.figure(figsize=(10, 6))
# Plotar o preço de fechamento para cada ação
for ticker in tickers:
# Filtrar os dados para o ticker atual
data = combined_data[combined_data['Ticker'] == ticker]
# Ordenar os dados por data
data = data.sort_values('Date')
# Plotar a série temporal do preço de fechamento
plt.plot(data['Date'], data['Close'], label=ticker)
# Configurar o título e os rótulos do gráfico
plt.title('Preço de Fechamento das Ações ao Longo do Tempo')
plt.xlabel('Data')
plt.ylabel('Preço de Fechamento (USD)')
# Adicionar uma legenda
plt.legend()
# Ajustar o layout para evitar sobreposição
plt.tight_layout()
# Exibir o gráfico
plt.show()
# Importar bibliotecas necessárias
import yfinance as yf
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
# Definir os tickers das ações e o período de tempo
tickers = ["AAPL", "MSFT", "GOOG", "AMZN"]
# Definir as datas de início e fim
start_date = "2010-01-01"
end_date = "2023-10-31"
# Função para obter dados históricos de ações usando yfinance
def get_data(ticker):
# Baixar os dados usando yfinance
df = yf.download(ticker, start=start_date, end=end_date)
# Adicionar uma coluna para identificar o ticker
df['Ticker'] = ticker
# Resetar o índice para transformar a coluna 'Date' em coluna regular
df = df.reset_index()
return df
# Coletar dados para cada ticker e combinar em um único DataFrame pandas
data_frames = [get_data(ticker) for ticker in tickers]
combined_data = pd.concat(data_frames, ignore_index=True)
# Remover valores nulos nas colunas 'Adj Close' e 'Date'
combined_data = combined_data.dropna(subset=['Adj Close', 'Date'])
# Adicionar uma coluna com o ano
combined_data['Year'] = combined_data['Date'].dt.year
# Análise de Dados
# Calcular a média do preço de fechamento ajustado para cada ação
average_adj_close = combined_data.groupby("Ticker")["Adj Close"].mean().reset_index()
print("Média do preço de fechamento ajustado por ação:")
print(average_adj_close)
# Calcular a volatilidade (desvio padrão) do preço de fechamento ajustado para cada ação
volatility_adj = combined_data.groupby("Ticker")["Adj Close"].std().reset_index()
print("\nVolatilidade do preço de fechamento ajustado por ação:")
print(volatility_adj)
# Calcular a média anual do preço de fechamento ajustado para cada ação
annual_average = combined_data.groupby(['Ticker', 'Year'])['Adj Close'].mean().reset_index()
# Calcular a volatilidade anual do preço de fechamento ajustado para cada ação
annual_volatility = combined_data.groupby(['Ticker', 'Year'])['Adj Close'].std().reset_index()
# Visualização dos Dados
# Configurar o estilo dos gráficos
sns.set_style('whitegrid')
# Gráfico de linha do preço de fechamento ajustado ao longo do tempo para cada ação
plt.figure(figsize=(12, 6))
for ticker in tickers:
data = combined_data[combined_data['Ticker'] == ticker]
plt.plot(data['Date'], data['Adj Close'], label=ticker)
plt.title('Preço de Fechamento Ajustado das Ações ao Longo do Tempo')
plt.xlabel('Data')
plt.ylabel('Preço de Fechamento Ajustado (USD)')
plt.legend()
plt.tight_layout()
plt.show()
# Gráfico de linha da média anual do preço de fechamento ajustado para cada ação
plt.figure(figsize=(12, 6))
sns.lineplot(data=annual_average, x='Year', y='Adj Close', hue='Ticker', marker='o')
plt.title('Média Anual do Preço de Fechamento Ajustado por Ação')
plt.xlabel('Ano')
plt.ylabel('Preço Médio de Fechamento Ajustado (USD)')
plt.tight_layout()
plt.show()
# Gráfico de linha da volatilidade anual do preço de fechamento ajustado para cada ação
plt.figure(figsize=(12, 6))
sns.lineplot(data=annual_volatility, x='Year', y='Adj Close', hue='Ticker', marker='o')
plt.title('Volatilidade Anual do Preço de Fechamento Ajustado por Ação')
plt.xlabel('Ano')
plt.ylabel('Volatilidade do Preço de Fechamento Ajustado (USD)')
plt.tight_layout()
plt.show()
# Análise de Retorno Acumulado
# Calcular o retorno diário
combined_data['Daily Return'] = combined_data.groupby('Ticker')['Adj Close'].pct_change()
# Calcular o retorno acumulado
combined_data['Cumulative Return'] = (1 + combined_data['Daily Return']).groupby(combined_data['Ticker']).cumprod()
# Gráfico de linha do retorno acumulado ao longo do tempo para cada ação
plt.figure(figsize=(12, 6))
for ticker in tickers:
data = combined_data[combined_data['Ticker'] == ticker]
plt.plot(data['Date'], data['Cumulative Return'], label=ticker)
plt.title('Retorno Acumulado das Ações ao Longo do Tempo')
plt.xlabel('Data')
plt.ylabel('Retorno Acumulado')
plt.legend()
plt.tight_layout()
plt.show()
# Importar bibliotecas necessárias
import dask.dataframe as dd
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
import os
# Configurar o estilo dos gráficos
sns.set_style('whitegrid')
# Criar um diretório para armazenar os dados, se não existir
os.makedirs('data', exist_ok=True)
# Função para gerar um grande conjunto de dados sintético
def create_large_dataset(num_files, rows_per_file):
for i in range(num_files):
# Gerar dados aleatórios
df = pd.DataFrame({
'Date': pd.date_range(start='2010-01-01', periods=rows_per_file, freq='T'),
'Ticker': np.random.choice(['AAPL', 'MSFT', 'GOOG', 'AMZN'], size=rows_per_file),
'Close': np.random.rand(rows_per_file) * 1000
})
# Salvar em CSV
df.to_csv(f'data/stock_data_{i}.csv', index=False)
print(f'Arquivo stock_data_{i}.csv criado.')
# Parâmetros para a geração de dados
num_files = 5          # Número de arquivos CSV
rows_per_file = 500000  # Número de linhas por arquivo
# Gerar o conjunto de dados (pode levar algum tempo)
create_large_dataset(num_files, rows_per_file)
# Ler os dados utilizando Dask
df = dd.read_csv('data/stock_data_*.csv', assume_missing=True)
# Converter a coluna 'Date' para datetime
df['Date'] = dd.to_datetime(df['Date'], errors='coerce')
# Remover valores nulos nas colunas 'Close' e 'Date'
df = df.dropna(subset=['Close', 'Date'])
# Análise de Dados
# Calcular a média do preço de fechamento para cada ação
average_close = df.groupby('Ticker')['Close'].mean().compute()
print("Média do preço de fechamento por ação:")
print(average_close)
# Calcular a volatilidade (desvio padrão) do preço de fechamento para cada ação
volatility = df.groupby('Ticker')['Close'].std().compute()
print("\nVolatilidade do preço de fechamento por ação:")
print(volatility)
# Visualização dos Dados
# Converter o DataFrame Dask para Pandas para plotagem
pdf = df.compute()
# Plotar o preço de fechamento ao longo do tempo para cada ação
plt.figure(figsize=(12, 6))
sns.lineplot(data=pdf, x='Date', y='Close', hue='Ticker', linewidth=0.5)
